# Internals

## Basic usage

The process of executing code in the interpreter is to prepare a `frame` and then
evaluate these statements one-by-one, branching via the `goto` statements as appropriate.
Using the `summer` example described in [Lowered representation](@ref),
let's build a frame:

```julia
julia> frame = JuliaInterpreter.enter_call(summer, A)
JuliaStackFrame(JuliaInterpreter.JuliaFrameCode(summer(A::AbstractArray{T,N} where N) where T in Main at REPL[1]:2, CodeInfo(
1 ─       s = ($(QuoteNode(zero)))($(Expr(:static_parameter, 1)))
│   %2  = A
│         #temp# = ($(QuoteNode(iterate)))(%2)
│   %4  = ($(QuoteNode(===)))(#temp#, nothing)
│   %5  = ($(QuoteNode(not_int)))(%4)
└──       goto #4 if not %5
2 ┄ %7  = #temp#
│         a = ($(QuoteNode(getfield)))(%7, 1)
│   %9  = ($(QuoteNode(getfield)))(%7, 2)
│         s = ($(QuoteNode(+)))(s, a)
│         #temp# = ($(QuoteNode(iterate)))(%2, %9)
│   %12 = ($(QuoteNode(===)))(#temp#, nothing)
│   %13 = ($(QuoteNode(not_int)))(%12)
└──       goto #4 if not %13
3 ─       goto #2
4 ┄       return s
), Core.TypeMapEntry[#undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef], BitSet([2, 4, 5, 7, 9, 12, 13]), false, false, true), Union{Nothing, Some{Any}}[Some(summer), Some([1, 2, 5]), nothing, nothing, nothing], Any[#undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef], Any[Int64], Int64[], Base.RefValue{Any}(nothing), Base.RefValue{JuliaInterpreter.JuliaProgramCounter}(JuliaProgramCounter(1)), Dict{Symbol,Int64}(), Any[])
```

This is a [`JuliaInterpreter.JuliaStackFrame`](@ref). The `CodeInfo` is the most prominent part of this display,
and extractable as `code = frame.code.code`. (It's a slightly modified form of one returned by `@code_lowered`,
in that it has been processed by [`JuliaInterpreter.optimize!`](@ref) to speed up run-time execution.)

Much of the rest of the `frame` holds values needed for or generated by execution.
The input arguments are in `locals`:

```julia
julia> frame.locals
5-element Array{Union{Nothing, Some{Any}},1}:
 Some(summer)
 Some([1, 2, 5])
 nothing
 nothing
 nothing
```

These correspond to the `code.slotnames`; the first is the `#self#` argument and the second
is the input array. The remaining local variables (e.g., `s` and `a`), have not yet been assigned---we've
only built the frame, but we haven't yet begun to execute it.
The static parameter, `T`, is stored in `frame.sparams`:

```julia
julia> frame.sparams
1-element Array{Any,1}:
 Int64
```

The `Expr(:static_parameter, 1)` statement refers to this value.

The other main storage is for the generated SSA values:

```julia
julia> frame.ssavalues
16-element Array{Any,1}:
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
```

Since we haven't executed any statements yet, these are all undefined.

The other main entity is the so-called [program counter](https://en.wikipedia.org/wiki/Program_counter),
which just indicates the next statement to be executed:

```julia
julia> frame.pc[]
JuliaProgramCounter(1)
```

This is stored as a `Ref` so that it can be updated as execution progresses.

Let's try executing the first statement. So that we can recurse into calls (e.g., `iterate`, `+`, etc.,),
we'll create a [stack](https://en.wikipedia.org/wiki/Call_stack) of frames and then run the first statement:

```julia
julia> stack = JuliaInterpreter.JuliaStackFrame[]
0-element Array{JuliaStackFrame,1}

julia> JuliaInterpreter.step_expr!(stack, frame)
JuliaProgramCounter(2)
```

This indicates that it ran statement 1 and is prepared to run statement 2.
(It's worth noting that the first line included a `call` to `zero`, so behind the scenes
JuliaInterpreter pushed this frame onto `stack`, created a new frame for `zero`,
executed all the statements, and then popped the stack.)
Since the first statement is an assignment of a local variable, let's check the
locals again:

```julia
julia> frame.locals
5-element Array{Union{Nothing, Some{Any}},1}:
 Some(summer)
 Some([1, 2, 5])
 Some(0)
 nothing
 nothing
```

You can see that the entry corresponding to `s` has been initialized.

The next statement just retrieves one of the slots (the input argument `A`) and stores
it in an SSA value:

```julia
julia> JuliaInterpreter.step_expr!(stack, frame)
JuliaProgramCounter(3)

julia> frame.ssavalues
16-element Array{Any,1}:
 #undef
    [1, 2, 5]
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
```

One can easily continue this until execution completes, which is indicated when `step_expr!`
returns `nothing`. Alternatively, use the higher-level `JuliaInterpreter.finish!(stack, frame)`
to step through the entire frame,
or `JuliaInterpreter.finish_and_return!(stack, frame)` to also obtain the return value.

## More complex expressions

Sometimes you might have a whole sequence of expressions you want to run.
In such cases, your first thought should be `prepare_thunk`.
Here's a demonstration:

```jldoctest; setup=(using JuliaInterpreter; empty!(JuliaInterpreter.junk))
using Test

ex = quote
    x, y = 1, 2
    @test x + y == 3
end

frame = JuliaInterpreter.prepare_thunk(Main, ex)
JuliaInterpreter.finish_and_return!(JuliaStackFrame[], frame)

# output

Test Passed
```

## Toplevel code and world age

Some code is more complicated and requires special handling: code that defines new `struct`s,
new methods, or new modules. In such cases, calling `finish_and_return!` on a frame that
defines these new objects and then calls them can trigger a
[world age error](https://docs.julialang.org/en/latest/manual/methods/#Redefining-Methods-1),
in which the method is considered to be too new to be run by the currently compiled code.

In such cases care is required to return to "top level" before continuing. Here's a demonstration:

```julia
ex = :(map(x->x^2, [1, 2, 3]))
frame = JuliaInterpreter.prepare_thunk(Main, ex)
julia> JuliaInterpreter.finish_and_return!(JuliaStackFrame[], frame)
ERROR: this should have been handled by prepare_toplevel
```

The reason becomes clearer if we examine `frame` or look directly at the lowered code:

```julia
julia> Meta.lower(Main, ex)
:($(Expr(:thunk, CodeInfo(
1 ─      $(Expr(:thunk, CodeInfo(
1 ─     global ##17#18
│       const ##17#18
│       $(Expr(:struct_type, Symbol("##17#18"), :((Core.svec)()), :((Core.svec)()), :(Core.Function), :((Core.svec)()), false, 0))
└──     return
)))
│   %2 = (Core.svec)(##17#18, Core.Any)
│   %3 = (Core.svec)()
│   %4 = (Core.svec)(%2, %3)
│        $(Expr(:method, false, :(%4), CodeInfo(quote
    (Core.apply_type)(Base.Val, 2)
    (%1)()
    (Base.literal_pow)(^, x, %2)
    return %3
end)))
│        #17 = %new(##17#18)
│   %7 = #17
│   %8 = (Base.vect)(1, 2, 3)
│   %9 = map(%7, %8)
└──      return %9
))))
```

All of the code before `%7` is devoted to defining the anonymous function `x->x^2`: it creates a new "anonymous type"
(here written as `##17#18`), and then defines a call function for this type, equivalent to `(##17#18)(x) = x^2`.
Since this is a new method, you need to return to top level to evaluate it:

```julia
frames, _ = JuliaInterpreter.prepare_toplevel(Main, ex)
stack = JuliaStackFrame[]
for frame in frames
    while true
        JuliaInterpreter.through_methoddef_or_done!(stack, frame) === nothing && break
    end
end
```

This splits the expression into a sequence of frames (here just one, but more complex blocks may be split up into many).
Then, each frame is executed until it finishes defining a new method, then returns to top level.
The return to top level causes an update in the world age.
If the frame hasn't been finished yet (if the return value wasn't `nothing`),
this continues executing where it left off.
You can extract the return value with

```julia
julia> JuliaInterpreter.get_return(frames[end])
3-element Array{Int64,1}:
 1
 4
 9
```

(Incidentally, `JuliaInterpreter.enter_call(map, x->x^2, [1, 2, 3])` works fine on its own,
because the anonymous function is defined by the caller---you'll see that the created frame
is very simple.)
