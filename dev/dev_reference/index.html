<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function reference · JuliaInterpreter.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaInterpreter.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../ast/">Lowered representation</a></li><li><a class="toctext" href="../internals/">Internals</a></li><li class="current"><a class="toctext" href>Function reference</a><ul class="internal"><li><a class="toctext" href="#Top-level-1">Top-level</a></li><li><a class="toctext" href="#Frame-creation-1">Frame creation</a></li><li><a class="toctext" href="#Frame-execution-1">Frame execution</a></li><li><a class="toctext" href="#Breakpoints-1">Breakpoints</a></li><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Internal-storage-1">Internal storage</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Function reference</a></li></ul><a class="edit-page" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/master/docs/src/dev_reference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Function reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Function-reference-1" href="#Function-reference-1">Function reference</a></h1><h2><a class="nav-anchor" id="Top-level-1" href="#Top-level-1">Top-level</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.@interpret" href="#JuliaInterpreter.@interpret"><code>JuliaInterpreter.@interpret</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@interpret f(args; kwargs...)</code></pre><p>Evaluate <code>f</code> on the specified arguments using the interpreter.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1, 7]
2-element Array{Int64,1}:
 1
 7

julia&gt; sum(a)
8

julia&gt; @interpret sum(a)
8</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L1091-L1110">source</a></section><h2><a class="nav-anchor" id="Frame-creation-1" href="#Frame-creation-1">Frame creation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.enter_call" href="#JuliaInterpreter.enter_call"><code>JuliaInterpreter.enter_call</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frame = enter_call(f, args...; kwargs...)</code></pre><p>Build a <code>JuliaStackFrame</code> ready to execute <code>f</code> with the specified positional and keyword arguments.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; mymethod(x) = x+1
mymethod (generic function with 1 method)

julia&gt; JuliaInterpreter.enter_call(mymethod, 1)
JuliaStackFrame(JuliaInterpreter.JuliaFrameCode(mymethod(x) in Main at none:1, CodeInfo(
1 ─ %1 = ($(QuoteNode(+)))(x, 1)
└──      return %1
), Union{Compiled, TypeMapEntry}[#undef, #undef], JuliaInterpreter.BreakpointState[#undef, #undef], BitSet([1]), false, false, true), Union{Nothing, Some{Any}}[Some(mymethod), Some(1)], Any[#undef, #undef], Any[], Int64[], Base.RefValue{Any}(nothing), Base.RefValue{JuliaInterpreter.JuliaProgramCounter}(JuliaProgramCounter(1)), Dict(Symbol(&quot;#self#&quot;)=&gt;1,:x=&gt;2), Any[])

julia&gt; mymethod(x::Vector{T}) where T = 1
mymethod (generic function with 2 methods)

julia&gt; JuliaInterpreter.enter_call(mymethod, [1.0, 2.0])
JuliaStackFrame(JuliaInterpreter.JuliaFrameCode(mymethod(x::Array{T,1}) where T in Main at none:1, CodeInfo(
1 ─     return 1
), Union{Compiled, TypeMapEntry}[#undef], JuliaInterpreter.BreakpointState[#undef], BitSet([]), false, false, true), Union{Nothing, Some{Any}}[Some(mymethod), Some([1.0, 2.0])], Any[#undef], Any[Float64], Int64[], Base.RefValue{Any}(nothing), Base.RefValue{JuliaInterpreter.JuliaProgramCounter}(JuliaProgramCounter(1)), Dict(Symbol(&quot;#self#&quot;)=&gt;1,:x=&gt;2), Any[])</code></pre><p>For a <code>@generated</code> function you can use <code>enter_call((f, true), args...; kwargs...)</code> to execute the generator of a <code>@generated</code> function, rather than the code that would be created by the generator.</p><p>See <a href="#JuliaInterpreter.enter_call_expr"><code>enter_call_expr</code></a> for a similar approach based on expressions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L987-L1018">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.enter_call_expr" href="#JuliaInterpreter.enter_call_expr"><code>JuliaInterpreter.enter_call_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frame = enter_call_expr(expr; enter_generated=false)</code></pre><p>Build a <code>JuliaStackFrame</code> ready to execute the expression <code>expr</code>. Set <code>enter_generated=true</code> if you want to execute the generator of a <code>@generated</code> function, rather than the code that would be created by the generator.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; mymethod(x) = x+1
mymethod (generic function with 1 method)

julia&gt; JuliaInterpreter.enter_call_expr(:($mymethod(1)))
JuliaStackFrame(JuliaInterpreter.JuliaFrameCode(mymethod(x) in Main at none:1, CodeInfo(
1 ─ %1 = ($(QuoteNode(+)))(x, 1)
└──      return %1
), Union{Compiled, TypeMapEntry}[#undef, #undef], JuliaInterpreter.BreakpointState[#undef, #undef], BitSet([1]), false, false, true), Union{Nothing, Some{Any}}[Some(mymethod), Some(1)], Any[#undef, #undef], Any[], Int64[], Base.RefValue{Any}(nothing), Base.RefValue{JuliaInterpreter.JuliaProgramCounter}(JuliaProgramCounter(1)), Dict(Symbol(&quot;#self#&quot;)=&gt;1,:x=&gt;2), Any[])

julia&gt; mymethod(x::Vector{T}) where T = 1
mymethod (generic function with 2 methods)

julia&gt; a = [1.0, 2.0]
2-element Array{Float64,1}:
 1.0
 2.0

julia&gt; JuliaInterpreter.enter_call_expr(:($mymethod($a)))
JuliaStackFrame(JuliaInterpreter.JuliaFrameCode(mymethod(x::Array{T,1}) where T in Main at none:1, CodeInfo(
1 ─     return 1
), Union{Compiled, TypeMapEntry}[#undef], JuliaInterpreter.BreakpointState[#undef], BitSet([]), false, false, true), Union{Nothing, Some{Any}}[Some(mymethod), Some([1.0, 2.0])], Any[#undef], Any[Float64], Int64[], Base.RefValue{Any}(nothing), Base.RefValue{JuliaInterpreter.JuliaProgramCounter}(JuliaProgramCounter(1)), Dict(Symbol(&quot;#self#&quot;)=&gt;1,:x=&gt;2), Any[])</code></pre><p>See <a href="#JuliaInterpreter.enter_call"><code>enter_call</code></a> for a similar approach not based on expressions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L944-L978">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.build_frame" href="#JuliaInterpreter.build_frame"><code>JuliaInterpreter.build_frame</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frame = build_frame(framecode::JuliaFrameCode, frameargs, lenv)</code></pre><p>Construct a new <code>JuliaStackFrame</code> for <code>framecode</code>, given lowered-code arguments <code>frameargs</code> and static parameters <code>lenv</code>. See <a href="#JuliaInterpreter.prepare_call"><code>JuliaInterpreter.prepare_call</code></a> for information about how to prepare the inputs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L926-L931">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.determine_method_for_expr" href="#JuliaInterpreter.determine_method_for_expr"><code>JuliaInterpreter.determine_method_for_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">framecode, frameargs, lenv, argtypes = determine_method_for_expr(expr; enter_generated = false)</code></pre><p>Prepare all the information needed to execute a particular <code>:call</code> expression <code>expr</code>. For example, try <code>JuliaInterpreter.determine_method_for_expr(:(sum([1,2])))</code>. See <a href="#JuliaInterpreter.prepare_call"><code>JuliaInterpreter.prepare_call</code></a> for information about the outputs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L635-L641">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.prepare_args" href="#JuliaInterpreter.prepare_args"><code>JuliaInterpreter.prepare_args</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frun, allargs = prepare_args(fcall, fargs, kwargs)</code></pre><p>Prepare the complete argument sequence for a call to <code>fcall</code>. <code>fargs = [fcall, args...]</code> is a list containing both <code>fcall</code> (the <code>#self#</code> slot in lowered code) and the positional arguments supplied to <code>fcall</code>. <code>kwargs</code> is a list of keyword arguments, supplied either as list of expressions <code>:(kwname=kwval)</code> or pairs <code>:kwname=&gt;kwval</code>.</p><p>For non-keyword methods, <code>frun === fcall</code>, but for methods with keywords <code>frun</code> will be the keyword-sorter function for <code>fcall</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; mymethod(x) = 1
mymethod (generic function with 1 method)

julia&gt; mymethod(x, y; verbose=false) = nothing
mymethod (generic function with 2 methods)

julia&gt; JuliaInterpreter.prepare_args(mymethod, [mymethod, 15], ())
(mymethod, Any[mymethod, 15])

julia&gt; JuliaInterpreter.prepare_args(mymethod, [mymethod, 1, 2], [:verbose=&gt;true])
(getfield( Symbol(&quot;#kw##mymethod&quot;))(), Any[#kw##mymethod(), (verbose = true,), mymethod, 1, 2])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L312-L338">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.prepare_call" href="#JuliaInterpreter.prepare_call"><code>JuliaInterpreter.prepare_call</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">framecode, frameargs, lenv, argtypes = prepare_call(f, allargs; enter_generated=false)</code></pre><p>Prepare all the information needed to execute lowered code for <code>f</code> given arguments <code>allargs</code>. <code>f</code> and <code>allargs</code> are the outputs of <a href="#JuliaInterpreter.prepare_args"><code>prepare_args</code></a>. For <code>@generated</code> methods, set <code>enter_generated=true</code> if you want to extract the lowered code of the generator itself.</p><p>On return <code>framecode</code> is the <a href="#JuliaInterpreter.JuliaFrameCode"><code>JuliaFrameCode</code></a> of the method. <code>frameargs</code> contains the actual arguments needed for executing this frame (for generators, this will be the types of <code>allargs</code>); <code>lenv</code> is the &quot;environment&quot;, i.e., the static parameters for <code>f</code> given <code>allargs</code>. <code>argtypes</code> is the <code>Tuple</code>-type for this specific call (equivalent to the signature of the <code>MethodInstance</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; mymethod(x::Vector{T}) where T = 1
mymethod (generic function with 1 method)

julia&gt; framecode, frameargs, lenv, argtypes = JuliaInterpreter.prepare_call(mymethod, [mymethod, [1.0,2.0]]);

julia&gt; framecode
JuliaInterpreter.JuliaFrameCode(mymethod(x::Array{T,1}) where T in Main at none:1, CodeInfo(
1 ─     return 1
), Union{Compiled, TypeMapEntry}[#undef], JuliaInterpreter.BreakpointState[#undef], BitSet([]), false, false, true)

julia&gt; frameargs
2-element Array{Any,1}:
 mymethod
 [1.0, 2.0]

julia&gt; lenv
svec(Float64)

julia&gt; argtypes
Tuple{typeof(mymethod),Array{Float64,1}}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L414-L452">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.prepare_thunk" href="#JuliaInterpreter.prepare_thunk"><code>JuliaInterpreter.prepare_thunk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frame = prepare_thunk(mod::Module, expr::Expr)</code></pre><p>Prepare <code>expr</code> for evaluation in <code>mod</code>. <code>expr</code> should be a &quot;straightforward&quot; expression, one that does not require special top-level handling (see <a href="#JuliaInterpreter.split_expressions"><code>JuliaInterpreter.split_expressions</code></a>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L482-L487">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.split_expressions" href="#JuliaInterpreter.split_expressions"><code>JuliaInterpreter.split_expressions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">modexs, docexprs = split_expressions(mod::Module, expr::Expr; extract_docexprs=false)</code></pre><p>Break <code>expr</code> into a list <code>modexs</code> of sequential blocks. This is often needed when <code>expr</code> needs to be evaluated at top level.</p><p><code>modexs[i]</code> is a <code>(mod::Module, ex::Expr)</code> tuple, where <code>ex</code> is to be evaluated in <code>mod</code>.</p><p><strong>Toplevel evaluation</strong></p><p>For code that defines new structs, new methods, or new macros, it can be important to evaluate these expressions carefully:</p><pre><code class="language-none">stack = JuliaStackFrame[]
for modex in modexs    # or use `for (mod, ex) in modexs` to split the tuple
    frame = JuliaInterpreter.prepare_thunk(modex)
    while true
        JuliaInterpreter.through_methoddef_or_done!(stack, frame) === nothing &amp;&amp; break
    end
end</code></pre><p>The <code>while</code> loop here deserves some explanation. Occasionally, a frame may define new methods (e.g., anonymous or local functions) and then call those methods. In such cases, running the entire frame as a single block (e.g., with <a href="#JuliaInterpreter.finish_and_return!"><code>JuliaInterpreter.finish_and_return!</code></a> can trigger &quot;method is too new...&quot; errors. Instead, the approach above runs each frame, but returns to the caller after any new method is defined. When this loop is running at top level (e.g., in the REPL), this allows the world age to update and thus avoid &quot;method is too new...&quot; errors.</p><p>Putting the above nested loop inside a function defeats its purpose, because inside a compiled function the world age will not update. If necessary, use the following strategy:</p><pre><code class="language-none">Core.eval(somemodule, Expr(:toplevel, quote
    body
))</code></pre><p>where <code>body</code> contains the nested loop, plus any preparatory statements required to make the necessary variables available at top level in <code>somemodule</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L505-L543">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.get_call_framecode" href="#JuliaInterpreter.get_call_framecode"><code>JuliaInterpreter.get_call_framecode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">framecode, lenv = get_call_framecode(fargs, parentframe::JuliaFrameCode, idx::Int)</code></pre><p>Return the framecode and environment for a call specified by <code>fargs = [f, args...]</code> (see <a href="#JuliaInterpreter.prepare_args"><code>prepare_args</code></a>). <code>parentframecode</code> is the caller, and <code>idx</code> is the program-counter index. If possible, <code>framecode</code> will be looked up from the local method tables of <code>parentframe</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/localmethtable.jl#L8-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.optimize!" href="#JuliaInterpreter.optimize!"><code>JuliaInterpreter.optimize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">optimize!(code::CodeInfo, mod::Module)</code></pre><p>Perform minor optimizations on the lowered AST in <code>code</code> to reduce execution time of the interpreter. Currently it looks up <code>GlobalRef</code>s (for which it needs <code>mod</code> to know the scope in which this will run) and ensures that no statement includes nested <code>:call</code> expressions (splitting them out into multiple SSA-form statements if needed).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L773-L781">source</a></section><h2><a class="nav-anchor" id="Frame-execution-1" href="#Frame-execution-1">Frame execution</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.Compiled" href="#JuliaInterpreter.Compiled"><code>JuliaInterpreter.Compiled</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Compiled</code> is a trait indicating that any <code>:call</code> expressions should be evaluated using Julia&#39;s normal compiled-code evaluation. The alternative is to pass <code>stack=JuliaStackFrame[]</code>, which will cause all calls to be evaluated via the interpreter.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L22-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.step_expr!" href="#JuliaInterpreter.step_expr!"><code>JuliaInterpreter.step_expr!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pc = step_expr!(stack, frame)</code></pre><p>Execute the next statement in <code>frame</code>. <code>pc</code> is the new program counter, or <code>nothing</code> if execution terminates. <code>stack</code> controls call evaluation; <code>stack = Compiled()</code> evaluates :call expressions by normal dispatch, whereas a vector of <code>JuliaStackFrame</code>s will use recursive interpretation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/interpret.jl#L476-L483">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.finish!" href="#JuliaInterpreter.finish!"><code>JuliaInterpreter.finish!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pc = finish!(stack, frame, pc=frame.pc[])</code></pre><p>Run <code>frame</code> until execution terminates. <code>pc</code> is the program counter for the final statement. <code>stack</code> controls call evaluation; <code>stack = Compiled()</code> evaluates :call expressions by normal dispatch, whereas a vector of <code>JuliaStackFrame</code>s will use recursive interpretation.</p><p>If execution hits a breakpoint, then <code>pc</code> is a reference to the breakpoint. <code>stack[end]</code>, if not running in <code>Compiled()</code> mode, will contain the frame in which the breakpoint was hit.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/interpret.jl#L514-L523">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.finish_and_return!" href="#JuliaInterpreter.finish_and_return!"><code>JuliaInterpreter.finish_and_return!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = finish_and_return!(stack, frame, istoplevel::Bool=false)
ret = finish_and_return!(stack, frame, pc, istoplevel::Bool)</code></pre><p>Run <code>frame</code> until execution terminates, and pass back the computed return value. <code>stack</code> controls call evaluation; <code>stack = Compiled()</code> evaluates :call expressions by normal dispatch, whereas a vector of <code>JuliaStackFrame</code>s will use recursive interpretation.</p><p>If execution hits a breakpoint, then <code>ret</code> is a reference to the breakpoint. <code>stack[end]</code>, if not running in <code>Compiled()</code> mode, will contain the frame in which the breakpoint was hit.</p><p>Optionally supply the starting <code>pc</code>, if you don&#39;t want to start at the current location in <code>frame</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/interpret.jl#L541-L553">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.finish_stack!" href="#JuliaInterpreter.finish_stack!"><code>JuliaInterpreter.finish_stack!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = finish_stack!(stack)</code></pre><p>Completely unwind <code>stack</code>, finishing it frame-by-frame. If execution hits a breakpoint, <code>ret</code> will be a reference to the breakpoint.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/interpret.jl#L575-L580">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.get_return" href="#JuliaInterpreter.get_return"><code>JuliaInterpreter.get_return</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = get_return(frame, pc=frame.pc[])</code></pre><p>Get the return value of <code>frame</code>. Throws an error if <code>pc</code> does not point to a <code>return</code> expression. <code>frame</code> must have already been executed so that the return value has been computed (see, e.g., <a href="#JuliaInterpreter.finish!"><code>JuliaInterpreter.finish!</code></a>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/interpret.jl#L561-L567">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.next_until!" href="#JuliaInterpreter.next_until!"><code>JuliaInterpreter.next_until!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">next_until!(predicate, stack, frame, pc=frame.pc[])</code></pre><p>Step through statements of <code>frame</code> until the next statement satifies <code>predicate(stmt)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/interpret.jl#L605-L609">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.through_methoddef_or_done!" href="#JuliaInterpreter.through_methoddef_or_done!"><code>JuliaInterpreter.through_methoddef_or_done!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">through_methoddef_or_done!(stack, frame)</code></pre><p>Runs <code>frame</code> at top level until it either finishes (e.g., hits a <code>return</code> statement) or defines a new method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/interpret.jl#L624-L629">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.evaluate_call!" href="#JuliaInterpreter.evaluate_call!"><code>JuliaInterpreter.evaluate_call!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = evaluate_call!(Compiled(), frame::JuliaStackFrame, call_expr, pc)
ret = evaluate_call!(stack,      frame::JuliaStackFrame, call_expr, pc)</code></pre><p>Evaluate a <code>:call</code> expression <code>call_expr</code> in the context of <code>frame</code>. The first causes it to be executed using Julia&#39;s normal dispatch (compiled code), whereas the second recurses in via the interpreter. <code>stack</code> should be a vector of <a href="#JuliaInterpreter.JuliaStackFrame"><code>JuliaStackFrame</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/interpret.jl#L222-L229">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.evaluate_foreigncall!" href="#JuliaInterpreter.evaluate_foreigncall!"><code>JuliaInterpreter.evaluate_foreigncall!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = evaluate_foreigncall!(stack, frame::JuliaStackFrame, call_expr, pc)</code></pre><p>Evaluate a <code>:foreigncall</code> (from a <code>ccall</code>) statement <code>callexpr</code> in the context of <code>frame</code>. <code>stack</code> and <code>pc</code> are unused, but supplied for consistency with <a href="#JuliaInterpreter.evaluate_call!"><code>evaluate_call!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/interpret.jl#L141-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.maybe_evaluate_builtin" href="#JuliaInterpreter.maybe_evaluate_builtin"><code>JuliaInterpreter.maybe_evaluate_builtin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = maybe_evaluate_builtin(frame, call_expr)</code></pre><p>If <code>call_expr</code> is to a builtin function, evaluate it, returning the result inside a <code>Some</code> wrapper. Otherwise, return <code>call_expr</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/builtins-julia1.1.jl#L12-L17">source</a></section><h2><a class="nav-anchor" id="Breakpoints-1" href="#Breakpoints-1">Breakpoints</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.Breakpoints.@breakpoint" href="#JuliaInterpreter.Breakpoints.@breakpoint"><code>JuliaInterpreter.Breakpoints.@breakpoint</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@breakpoint f(args...) condition=nothing
@breakpoint f(args...) line condition=nothing</code></pre><p>Break upon entry, or at the specified line number, in the method called by <code>f(args...)</code>. Optionally supply a condition expressed in terms of the arguments and internal variables of the method. If <code>line</code> is supplied, it must be a literal integer.</p><p><strong>Example</strong></p><p>Suppose a method <code>mysum</code> is defined as follows, where the numbers to the left are the line number in the file:</p><pre><code class="language-none">12 function mysum(A)
13     s = zero(eltype(A))
14     for a in A
15         s += a
16     end
17     return s
18 end</code></pre><p>Then</p><pre><code class="language-none">@breakpoint mysum(A) 15 s&gt;10</code></pre><p>would cause execution of the loop to break whenever <code>s&gt;10</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/breakpoints.jl#L241-L272">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.Breakpoints.breakpoint" href="#JuliaInterpreter.Breakpoints.breakpoint"><code>JuliaInterpreter.Breakpoints.breakpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">breakpoint(f, sig)
breakpoint(f, sig, line)
breakpoint(f, sig, condition)
breakpoint(f, sig, line, condition)
breakpoint(...; enter_generated=false)</code></pre><p>Add a breakpoint to <code>f</code> with the specified argument types <code>sig</code>. Optionally specify an absolute line number <code>line</code> in the source file; the default is to break upon entry at the first line of the body. Without <code>condition</code>, the breakpoint will be triggered every time it is encountered; the second only if <code>condition</code> evaluates to <code>true</code>. <code>condition</code> should be written in terms of the arguments and local variables of <code>f</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">function radius2(x, y)
    return x^2 + y^2
end

breakpoint(radius2, Tuple{Int,Int}, :(y &gt; x))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/breakpoints.jl#L173-L195">source</a><div><div><pre><code class="language-none">breakpoint(method::Method)
breakpoint(method::Method, line)
breakpoint(method::Method, condition::Expr)
breakpoint(method::Method, line, condition::Expr)</code></pre><p>Add a breakpoint to <code>method</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/breakpoints.jl#L210-L217">source</a><div><div><pre><code class="language-none">breakpoint(f)
breakpoint(f, condition)</code></pre><p>Break-on-entry to all methods of <code>f</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/breakpoints.jl#L227-L232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.Breakpoints.enable" href="#JuliaInterpreter.Breakpoints.enable"><code>JuliaInterpreter.Breakpoints.enable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">enable(bp::BreakpointRef)</code></pre><p>Enable breakpoint <code>bp</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/breakpoints.jl#L120-L124">source</a><div><div><pre><code class="language-none">enable()</code></pre><p>Enable all breakpoints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/breakpoints.jl#L146-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.Breakpoints.disable" href="#JuliaInterpreter.Breakpoints.disable"><code>JuliaInterpreter.Breakpoints.disable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">disable(bp::BreakpointRef)</code></pre><p>Disable breakpoint <code>bp</code>. Disabled breakpoints can be re-enabled with <a href="#JuliaInterpreter.Breakpoints.enable"><code>enable</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/breakpoints.jl#L127-L131">source</a><div><div><pre><code class="language-none">disable()</code></pre><p>Disable all breakpoints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/breakpoints.jl#L153-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.Breakpoints.remove" href="#JuliaInterpreter.Breakpoints.remove"><code>JuliaInterpreter.Breakpoints.remove</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">remove(bp::BreakpointRef)</code></pre><p>Remove (delete) breakpoint <code>bp</code>. Removed breakpoints cannot be re-enabled.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/breakpoints.jl#L134-L138">source</a><div><div><pre><code class="language-none">remove()</code></pre><p>Remove all breakpoints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/breakpoints.jl#L160-L164">source</a></section><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.JuliaStackFrame" href="#JuliaInterpreter.JuliaStackFrame"><code>JuliaInterpreter.JuliaStackFrame</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>JuliaStackFrame</code> represents the current execution state in a particular call frame.</p><p>Important fields:</p><ul><li><code>code</code>: the <a href="#JuliaInterpreter.JuliaFrameCode"><code>JuliaFrameCode</code></a> for this frame</li><li><code>locals</code>: a vector containing the input arguments and named local variables for this frame. The indexing corresponds to the names in <code>frame.code.code.slotnames</code>.</li><li><code>ssavalues</code>: a vector containing the <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">Static Single Assignment</a> values produced at the current state of execution</li><li><code>sparams</code>: the static type parameters, e.g., for <code>f(x::Vector{T}) where T</code> this would store the value of <code>T</code> given the particular input <code>x</code>.</li><li><code>pc</code>: the <a href="#JuliaInterpreter.JuliaProgramCounter"><code>JuliaProgramCounter</code></a> that typically represents the current position during execution. However, note that some internal functions instead maintain the <code>pc</code> as a local variable, and only update the frame&#39;s <code>pc</code> when pushing a frame on the stack.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L116-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.JuliaFrameCode" href="#JuliaInterpreter.JuliaFrameCode"><code>JuliaInterpreter.JuliaFrameCode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>JuliaFrameCode</code> holds static information about a method or toplevel code. One <code>JuliaFrameCode</code> can be shared by many <code>JuliaStackFrame</code> calling frames.</p><p>Important fields:</p><ul><li><code>scope</code>: the <code>Method</code> or <code>Module</code> in which this frame is to be evaluated</li><li><code>code</code>: the <code>CodeInfo</code> object storing (optimized) lowered code</li><li><code>methodtables</code>: a vector, each entry potentially stores a &quot;local method table&quot; for the corresponding <code>:call</code> expression in <code>code</code> (undefined entries correspond to statements that do not contain <code>:call</code> expressions)</li><li><code>used</code>: a <code>BitSet</code> storing the list of SSAValues that get referenced by later statements.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L75-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.JuliaProgramCounter" href="#JuliaInterpreter.JuliaProgramCounter"><code>JuliaInterpreter.JuliaProgramCounter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">JuliaProgramCounter(next_stmt::Int)</code></pre><p>A wrapper specifying the index of the next statement in the lowered code to be executed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L30-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.BreakpointState" href="#JuliaInterpreter.BreakpointState"><code>JuliaInterpreter.BreakpointState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BreakpointState(isactive=true, condition=JuliaInterpreter.truecondition)</code></pre><p><code>BreakpointState</code> represents a breakpoint at a particular statement in a <code>JuliaFrameCode</code>. <code>isactive</code> indicates whether the breakpoint is currently <a href="#JuliaInterpreter.Breakpoints.enable"><code>enable</code></a>d or <a href="#JuliaInterpreter.Breakpoints.disable"><code>disable</code></a>d. <code>condition</code> is a function that accepts a single <code>JuliaStackFrame</code>, and <code>condition(frame)</code> must return either <code>true</code> or <code>false</code>. Execution will stop at a breakpoint only if <code>isactive</code> and <code>condition(frame)</code> both evaluate as <code>true</code>. The default <code>condition</code> always returns <code>true</code>.</p><p>To create these objects, see <a href="#JuliaInterpreter.Breakpoints.breakpoint"><code>breakpoint</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L50-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.Breakpoints.BreakpointRef" href="#JuliaInterpreter.Breakpoints.BreakpointRef"><code>JuliaInterpreter.Breakpoints.BreakpointRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BreakpointRef(framecode, stmtidx)
BreakpointRef(framecode, stmtidx, err)</code></pre><p>A reference to a breakpoint at a particular statement index <code>stmtidx</code> in <code>framecode</code>. If the break was due to an error, supply that as well.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/breakpoints.jl#L15-L21">source</a></section><h2><a class="nav-anchor" id="Internal-storage-1" href="#Internal-storage-1">Internal storage</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.framedict" href="#JuliaInterpreter.framedict"><code>JuliaInterpreter.framedict</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>framedict[method]</code> returns the <code>JuliaFrameCode</code> for <code>method</code>. For <code>@generated</code> methods, see <a href="#JuliaInterpreter.genframedict"><code>genframedict</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L200-L203">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.genframedict" href="#JuliaInterpreter.genframedict"><code>JuliaInterpreter.genframedict</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>genframedict[(method,argtypes)]</code> returns the <code>JuliaFrameCode</code> for a <code>@generated</code> method <code>method</code>, for the particular argument types <code>argtypes</code>.</p><p>The framecodes stored in <code>genframedict</code> are for the code returned by the generator (i.e, what will run when you call the method on particular argument types); for the generator itself, its framecode would be stored in <a href="#JuliaInterpreter.framedict"><code>framedict</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L206-L213">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.compiled_methods" href="#JuliaInterpreter.compiled_methods"><code>JuliaInterpreter.compiled_methods</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>meth ∈ compiled_methods</code> indicates that <code>meth</code> should be run using <a href="#JuliaInterpreter.Compiled"><code>Compiled</code></a> rather than recursed into via the interpreter.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L216-L219">source</a></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.@lookup" href="#JuliaInterpreter.@lookup"><code>JuliaInterpreter.@lookup</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">rhs = @lookup(frame, node)
rhs = @lookup(mod, frame, node)</code></pre><p>This macro looks up previously-computed values referenced as SSAValues, SlotNumbers, GlobalRefs, QuoteNode, sparam or exception reference expression. It will also lookup symbols in <code>moduleof(frame)</code>; this can be supplied ahead-of-time via the 3-argument version. If none of the above apply, the value of <code>node</code> will be returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/interpret.jl#L24-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.iswrappercall" href="#JuliaInterpreter.iswrappercall"><code>JuliaInterpreter.iswrappercall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Determine whether we are calling a function for which the current function is a wrapper (either because of optional arguments or becaue of keyword arguments).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/interpret.jl#L657-L660">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.isdocexpr" href="#JuliaInterpreter.isdocexpr"><code>JuliaInterpreter.isdocexpr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isdocexpr(ex)</code></pre><p>Test whether expression <code>ex</code> is a <code>@doc</code> expression.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L558-L562">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.isglobalref" href="#JuliaInterpreter.isglobalref"><code>JuliaInterpreter.isglobalref</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isglobalref(g, mod, name)</code></pre><p>Tests whether <code>g</code> is equal to <code>GlobalRef(mod, name)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L256-L260">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.statementnumber" href="#JuliaInterpreter.statementnumber"><code>JuliaInterpreter.statementnumber</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stmtidx = statementnumber(frame, line)</code></pre><p>Return the index of the first statement in <code>frame</code>&#39;s <code>CodeInfo</code> that corresponds to <code>line</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/interpret.jl#L720-L724">source</a><div><div><pre><code class="language-none">framecode, stmtidx = statementnumber(method, line)</code></pre><p>Return the index of the first statement in <code>framecode</code> that corresponds to the given <code>line</code> in <code>method</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/interpret.jl#L732-L736">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.Variable" href="#JuliaInterpreter.Variable"><code>JuliaInterpreter.Variable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Variable</code> is a struct representing a variable with an asigned value. By calling the function <code>locals</code>[@ref] on a <code>JuliaStackFrame</code>[@ref] a <code>Vector</code> of <code>Variable</code>&#39;s is returned.</p><p>Important fields:</p><ul><li><code>value::Any</code>: the value of the local variable</li><li><code>name::Symbol</code>: the name of the variable as given in the source code</li><li><code>isparam::Bool</code>: if the variable is a type parameter, for example <code>T</code> in <code>f(x::T) where {T} = x</code> .</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L161-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.locals" href="#JuliaInterpreter.locals"><code>JuliaInterpreter.locals</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">local_variables = locals(frame::JuliaStackFrame)::Vector{Variable}</code></pre><p>Return the local variables as a vector of <code>Variable</code>[@ref].</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/JuliaInterpreter.jl#L180-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CodeTracking.whereis" href="#CodeTracking.whereis"><code>CodeTracking.whereis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">loc = whereis(frame, pc=frame.pc[])</code></pre><p>Return the file and line number for <code>frame</code> at <code>pc</code>.  If this cannot be determined, <code>loc == nothing</code>. Otherwise <code>loc == (filepath, line)</code>.</p><p>When <code>frame</code> represents top-level code,</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/f92487ceb5baf2acce503902b2dfd73588737021/src/interpret.jl#L685-L692">source</a></section><footer><hr/><a class="previous" href="../internals/"><span class="direction">Previous</span><span class="title">Internals</span></a></footer></article></body></html>
