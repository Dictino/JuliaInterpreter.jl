<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function reference · JuliaInterpreter.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaInterpreter.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../ast/">Lowered representation</a></li><li><a class="toctext" href="../internals/">Internals</a></li><li class="current"><a class="toctext" href>Function reference</a><ul class="internal"><li><a class="toctext" href="#Top-level-1">Top-level</a></li><li><a class="toctext" href="#Frame-creation-1">Frame creation</a></li><li><a class="toctext" href="#Frame-execution-1">Frame execution</a></li><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Internal-storage-1">Internal storage</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Function reference</a></li></ul><a class="edit-page" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/master/docs/src/dev_reference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Function reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Function-reference-1" href="#Function-reference-1">Function reference</a></h1><h2><a class="nav-anchor" id="Top-level-1" href="#Top-level-1">Top-level</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.@interpret" href="#JuliaInterpreter.@interpret"><code>JuliaInterpreter.@interpret</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@interpret f(args; kwargs...)</code></pre><p>Evaluate <code>f</code> on the specified arguments using the interpreter.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1, 7]
2-element Array{Int64,1}:
 1
 7

julia&gt; sum(a)
8

julia&gt; @interpret sum(a)
8</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/JuliaInterpreter.jl#L831-L850">source</a></section><h2><a class="nav-anchor" id="Frame-creation-1" href="#Frame-creation-1">Frame creation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.enter_call" href="#JuliaInterpreter.enter_call"><code>JuliaInterpreter.enter_call</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frame = enter_call(f, args...; kwargs...)</code></pre><p>Build a <code>JuliaStackFrame</code> ready to execute <code>f</code> with the specified positional and keyword arguments.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; mymethod(x) = x+1
mymethod (generic function with 1 method)

julia&gt; JuliaInterpreter.enter_call(mymethod, 1)
JuliaStackFrame(JuliaInterpreter.JuliaFrameCode(mymethod(x) in Main at none:1, CodeInfo(
1 ─ %1 = ($(QuoteNode(+)))(x, 1)
└──      return %1
), Core.TypeMapEntry[#undef, #undef], BitSet([1]), false, false, true), Union{Nothing, Some{Any}}[Some(mymethod), Some(1)], Any[#undef, #undef], Any[], Int64[], Base.RefValue{Any}(nothing), Base.RefValue{JuliaInterpreter.JuliaProgramCounter}(JuliaProgramCounter(1)), Dict{Symbol,Int64}(), Any[])

julia&gt; mymethod(x::Vector{T}) where T = 1
mymethod (generic function with 2 methods)

julia&gt; JuliaInterpreter.enter_call(mymethod, [1.0, 2.0])
JuliaStackFrame(JuliaInterpreter.JuliaFrameCode(mymethod(x::Array{T,1}) where T in Main at none:1, CodeInfo(
1 ─     return 1
), Core.TypeMapEntry[#undef], BitSet([]), false, false, true), Union{Nothing, Some{Any}}[Some(mymethod), Some([1.0, 2.0])], Any[#undef], Any[Float64], Int64[], Base.RefValue{Any}(nothing), Base.RefValue{JuliaInterpreter.JuliaProgramCounter}(JuliaProgramCounter(1)), Dict{Symbol,Int64}(), Any[])</code></pre><p>For a <code>@generated</code> function you can use <code>enter_call((f, true), args...; kwargs...)</code> to execute the generator of a <code>@generated</code> function, rather than the code that would be created by the generator.</p><p>See <a href="#JuliaInterpreter.enter_call_expr"><code>enter_call_expr</code></a> for a similar approach based on expressions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/JuliaInterpreter.jl#L632-L663">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.enter_call_expr" href="#JuliaInterpreter.enter_call_expr"><code>JuliaInterpreter.enter_call_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frame = enter_call_expr(expr; enter_generated=false)</code></pre><p>Build a <code>JuliaStackFrame</code> ready to execute the expression <code>expr</code>. Set <code>enter_generated=true</code> if you want to execute the generator of a <code>@generated</code> function, rather than the code that would be created by the generator.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; mymethod(x) = x+1
mymethod (generic function with 1 method)

julia&gt; JuliaInterpreter.enter_call_expr(:($mymethod(1)))
JuliaStackFrame(JuliaInterpreter.JuliaFrameCode(mymethod(x) in Main at none:1, CodeInfo(
1 ─ %1 = ($(QuoteNode(+)))(x, 1)
└──      return %1
), Core.TypeMapEntry[#undef, #undef], BitSet([1]), false, false, true), Union{Nothing, Some{Any}}[Some(mymethod), Some(1)], Any[#undef, #undef], Any[], Int64[], Base.RefValue{Any}(nothing), Base.RefValue{JuliaInterpreter.JuliaProgramCounter}(JuliaProgramCounter(1)), Dict{Symbol,Int64}(), Any[])

julia&gt; mymethod(x::Vector{T}) where T = 1
mymethod (generic function with 2 methods)

julia&gt; a = [1.0, 2.0]
2-element Array{Float64,1}:
 1.0
 2.0

julia&gt; JuliaInterpreter.enter_call_expr(:($mymethod($a)))
JuliaStackFrame(JuliaInterpreter.JuliaFrameCode(mymethod(x::Array{T,1}) where T in Main at none:1, CodeInfo(
1 ─     return 1
), Core.TypeMapEntry[#undef], BitSet([]), false, false, true), Union{Nothing, Some{Any}}[Some(mymethod), Some([1.0, 2.0])], Any[#undef], Any[Float64], Int64[], Base.RefValue{Any}(nothing), Base.RefValue{JuliaInterpreter.JuliaProgramCounter}(JuliaProgramCounter(1)), Dict{Symbol,Int64}(), Any[])</code></pre><p>See <a href="#JuliaInterpreter.enter_call"><code>enter_call</code></a> for a similar approach not based on expressions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/JuliaInterpreter.jl#L589-L623">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.build_frame" href="#JuliaInterpreter.build_frame"><code>JuliaInterpreter.build_frame</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frame = build_frame(framecode::JuliaFrameCode, frameargs, lenv)</code></pre><p>Construct a new <code>JuliaStackFrame</code> for <code>framecode</code>, given lowered-code arguments <code>frameargs</code> and static parameters <code>lenv</code>. See <a href="#JuliaInterpreter.prepare_call"><code>JuliaInterpreter.prepare_call</code></a> for information about how to prepare the inputs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/JuliaInterpreter.jl#L572-L577">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.determine_method_for_expr" href="#JuliaInterpreter.determine_method_for_expr"><code>JuliaInterpreter.determine_method_for_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">framecode, frameargs, lenv, argtypes = determine_method_for_expr(expr; enter_generated = false)</code></pre><p>Prepare all the information needed to execute a particular <code>:call</code> expression <code>expr</code>. For example, try <code>JuliaInterpreter.determine_method_for_expr(:(sum([1,2])))</code>. See <a href="#JuliaInterpreter.prepare_call"><code>JuliaInterpreter.prepare_call</code></a> for information about the outputs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/JuliaInterpreter.jl#L344-L350">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.prepare_args" href="#JuliaInterpreter.prepare_args"><code>JuliaInterpreter.prepare_args</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frun, allargs = prepare_args(fcall, fargs, kwargs)</code></pre><p>Prepare the complete argument sequence for a call to <code>fcall</code>. <code>fargs = [fcall, args...]</code> is a list containing both <code>fcall</code> (the <code>#self#</code> slot in lowered code) and the positional arguments supplied to <code>fcall</code>. <code>kwargs</code> is a list of keyword arguments, supplied either as list of expressions <code>:(kwname=kwval)</code> or pairs <code>:kwname=&gt;kwval</code>.</p><p>For non-keyword methods, <code>frun === fcall</code>, but for methods with keywords <code>frun</code> will be the keyword-sorter function for <code>fcall</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; mymethod(x) = 1
mymethod (generic function with 1 method)

julia&gt; mymethod(x, y; verbose=false) = nothing
mymethod (generic function with 2 methods)

julia&gt; JuliaInterpreter.prepare_args(mymethod, [mymethod, 15], ())
(mymethod, Any[mymethod, 15])

julia&gt; JuliaInterpreter.prepare_args(mymethod, [mymethod, 1, 2], [:verbose=&gt;true])
(getfield( Symbol(&quot;#kw##mymethod&quot;))(), Any[#kw##mymethod(), (verbose = true,), mymethod, 1, 2])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/JuliaInterpreter.jl#L192-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.prepare_call" href="#JuliaInterpreter.prepare_call"><code>JuliaInterpreter.prepare_call</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">framecode, frameargs, lenv, argtypes = prepare_call(f, allargs; enter_generated=false)</code></pre><p>Prepare all the information needed to execute lowered code for <code>f</code> given arguments <code>allargs</code>. <code>f</code> and <code>allargs</code> are the outputs of <a href="#JuliaInterpreter.prepare_args"><code>prepare_args</code></a>. For <code>@generated</code> methods, set <code>enter_generated=true</code> if you want to extract the lowered code of the generator itself.</p><p>On return <code>framecode</code> is the <a href="#JuliaInterpreter.JuliaFrameCode"><code>JuliaFrameCode</code></a> of the method. <code>frameargs</code> contains the actual arguments needed for executing this frame (for generators, this will be the types of <code>allargs</code>); <code>lenv</code> is the &quot;environment&quot;, i.e., the static parameters for <code>f</code> given <code>allargs</code>. <code>argtypes</code> is the <code>Tuple</code>-type for this specific call (equivalent to the signature of the <code>MethodInstance</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; mymethod(x::Vector{T}) where T = 1
mymethod (generic function with 1 method)

julia&gt; framecode, frameargs, lenv, argtypes = JuliaInterpreter.prepare_call(mymethod, [mymethod, [1.0,2.0]]);

julia&gt; framecode
JuliaInterpreter.JuliaFrameCode(mymethod(x::Array{T,1}) where T in Main at none:1, CodeInfo(
1 ─     return 1
), Core.TypeMapEntry[#undef], BitSet([]), false, false, true)

julia&gt; frameargs
2-element Array{Any,1}:
 mymethod
 [1.0, 2.0]

julia&gt; lenv
svec(Float64)

julia&gt; argtypes
Tuple{typeof(mymethod),Array{Float64,1}}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/JuliaInterpreter.jl#L231-L269">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.get_call_framecode" href="#JuliaInterpreter.get_call_framecode"><code>JuliaInterpreter.get_call_framecode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">framecode, lenv = get_call_framecode(fargs, parentframe::JuliaFrameCode, idx::Int)</code></pre><p>Return the framecode and environment for a call specified by <code>fargs = [f, args...]</code> (see <a href="#JuliaInterpreter.prepare_args"><code>prepare_args</code></a>). <code>parentframecode</code> is the caller, and <code>idx</code> is the program-counter index. If possible, <code>framecode</code> will be looked up from the local method tables of <code>parentframe</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/localmethtable.jl#L3-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.optimize!" href="#JuliaInterpreter.optimize!"><code>JuliaInterpreter.optimize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">optimize!(code::CodeInfo, mod::Module)</code></pre><p>Perform minor optimizations on the lowered AST in <code>code</code> to reduce execution time of the interpreter. Currently it looks up <code>GlobalRef</code>s (for which it needs <code>mod</code> to know the scope in which this will run) and ensures that no statement includes nested <code>:call</code> expressions (splitting them out into multiple SSA-form statements if needed).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/JuliaInterpreter.jl#L453-L461">source</a></section><h2><a class="nav-anchor" id="Frame-execution-1" href="#Frame-execution-1">Frame execution</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.Compiled" href="#JuliaInterpreter.Compiled"><code>JuliaInterpreter.Compiled</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Compiled</code> is a trait indicating that any <code>:call</code> expressions should be evaluated using Julia&#39;s normal compiled-code evaluation. The alternative is to pass <code>stack=JuliaStackFrame[]</code>, which will cause all calls to be evaluated via the interpreter.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/JuliaInterpreter.jl#L10-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.step_expr!" href="#JuliaInterpreter.step_expr!"><code>JuliaInterpreter.step_expr!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pc = step_expr!(stack, frame)</code></pre><p>Execute the next statement in <code>frame</code>. <code>pc</code> is the new program counter, or <code>nothing</code> if execution terminates. <code>stack</code> controls call evaluation; <code>stack = Compiled()</code> evaluates :call expressions by normal dispatch, whereas a vector of <code>JuliaStackFrame</code>s will use recursive interpretation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/interpret.jl#L410-L417">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.finish!" href="#JuliaInterpreter.finish!"><code>JuliaInterpreter.finish!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pc = finish!(stack, frame, pc=frame.pc[])</code></pre><p>Run <code>frame</code> until execution terminates. <code>pc</code> is the program counter for the final statement. <code>stack</code> controls call evaluation; <code>stack = Compiled()</code> evaluates :call expressions by normal dispatch, whereas a vector of <code>JuliaStackFrame</code>s will use recursive interpretation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/interpret.jl#L424-L430">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.finish_and_return!" href="#JuliaInterpreter.finish_and_return!"><code>JuliaInterpreter.finish_and_return!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = finish_and_return!(stack, frame, pc=frame.pc[])</code></pre><p>Run <code>frame</code> until execution terminates, and pass back the computed return value. <code>stack</code> controls call evaluation; <code>stack = Compiled()</code> evaluates :call expressions by normal dispatch, whereas a vector of <code>JuliaStackFrame</code>s will use recursive interpretation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/interpret.jl#L441-L447">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.next_until!" href="#JuliaInterpreter.next_until!"><code>JuliaInterpreter.next_until!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">next_until!(predicate, stack, frame, pc=frame.pc[])</code></pre><p>Step through statements of <code>frame</code> until the next statement satifies <code>predicate(stmt)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/interpret.jl#L461-L465">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.evaluate_call!" href="#JuliaInterpreter.evaluate_call!"><code>JuliaInterpreter.evaluate_call!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = evaluate_call!(Compiled(), frame::JuliaStackFrame, call_expr, pc)
ret = evaluate_call!(stack,      frame::JuliaStackFrame, call_expr, pc)</code></pre><p>Evaluate a <code>:call</code> expression <code>call_expr</code> in the context of <code>frame</code>. The first causes it to be executed using Julia&#39;s normal dispatch (compiled code), whereas the second recurses in via the interpreter. <code>stack</code> should be a vector of <a href="#JuliaInterpreter.JuliaStackFrame"><code>JuliaStackFrame</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/interpret.jl#L177-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.evaluate_foreigncall!" href="#JuliaInterpreter.evaluate_foreigncall!"><code>JuliaInterpreter.evaluate_foreigncall!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = evaluate_foreigncall!(stack, frame::JuliaStackFrame, call_expr, pc)</code></pre><p>Evaluate a <code>:foreigncall</code> (from a <code>ccall</code>) statement <code>callexpr</code> in the context of <code>frame</code>. <code>stack</code> and <code>pc</code> are unused, but supplied for consistency with <a href="#JuliaInterpreter.evaluate_call!"><code>evaluate_call!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/interpret.jl#L119-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.maybe_evaluate_builtin" href="#JuliaInterpreter.maybe_evaluate_builtin"><code>JuliaInterpreter.maybe_evaluate_builtin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = maybe_evaluate_builtin(frame, call_expr)</code></pre><p>If <code>call_expr</code> is to a builtin function, evaluate it, returning the result inside a <code>Some</code> wrapper. Otherwise, return <code>call_expr</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/builtins.jl#L12-L17">source</a></section><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.JuliaStackFrame" href="#JuliaInterpreter.JuliaStackFrame"><code>JuliaInterpreter.JuliaStackFrame</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>JuliaStackFrame</code> represents the current execution state in a particular call frame.</p><p>Important fields:</p><ul><li><code>code</code>: the <a href="#JuliaInterpreter.JuliaFrameCode"><code>JuliaFrameCode</code></a> for this frame</li><li><code>locals</code>: a vector containing the input arguments and named local variables for this frame. The indexing corresponds to the names in <code>frame.code.code.slotnames</code>.</li><li><code>ssavalues</code>: a vector containing the <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">Static Single Assignment</a> values produced at the current state of execution</li><li><code>sparams</code>: the static type parameters, e.g., for <code>f(x::Vector{T}) where T</code> this would store the value of <code>T</code> given the particular input <code>x</code>.</li><li><code>pc</code>: the <a href="#JuliaInterpreter.JuliaProgramCounter"><code>JuliaProgramCounter</code></a> that typically represents the current position during execution. However, note that some internal functions instead maintain the <code>pc</code> as a local variable, and only update the frame&#39;s <code>pc</code> when pushing a frame on the stack.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/JuliaInterpreter.jl#L71-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.JuliaFrameCode" href="#JuliaInterpreter.JuliaFrameCode"><code>JuliaInterpreter.JuliaFrameCode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>JuliaFrameCode</code> holds static information about a method or toplevel code. One <code>JuliaFrameCode</code> can be shared by many <code>JuliaFrameState</code> calling frames.</p><p>Important fields:</p><ul><li><code>scope</code>: the <code>Method</code> or <code>Module</code> in which this frame is to be evaluated</li><li><code>code</code>: the <code>CodeInfo</code> object storing (optimized) lowered code</li><li><code>methodtables</code>: a vector, each entry potentially stores a &quot;local method table&quot; for the corresponding <code>:call</code> expression in <code>code</code> (undefined entries correspond to statements that do not contain <code>:call</code> expressions)</li><li><code>used</code>: a <code>BitSet</code> storing the list of SSAValues that get referenced by later statements.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/JuliaInterpreter.jl#L36-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.JuliaProgramCounter" href="#JuliaInterpreter.JuliaProgramCounter"><code>JuliaInterpreter.JuliaProgramCounter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">JuliaProgramCounter(next_stmt::Int)</code></pre><p>A wrapper specifying the index of the next statement in the lowered code to be executed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/JuliaInterpreter.jl#L17-L21">source</a></section><h2><a class="nav-anchor" id="Internal-storage-1" href="#Internal-storage-1">Internal storage</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.framedict" href="#JuliaInterpreter.framedict"><code>JuliaInterpreter.framedict</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>framedict[method]</code> returns the <code>JuliaFrameCode</code> for <code>method</code>. For <code>@generated</code> methods, see <a href="#JuliaInterpreter.genframedict"><code>genframedict</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/JuliaInterpreter.jl#L116-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.genframedict" href="#JuliaInterpreter.genframedict"><code>JuliaInterpreter.genframedict</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>genframedict[(method,argtypes)]</code> returns the <code>JuliaFrameCode</code> for a <code>@generated</code> method <code>method</code>, for the particular argument types <code>argtypes</code>.</p><p>The framecodes stored in <code>genframedict</code> are for the code returned by the generator (i.e, what will run when you call the method on particular argument types); for the generator itself, its framecode would be stored in <a href="#JuliaInterpreter.framedict"><code>framedict</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/JuliaInterpreter.jl#L121-L128">source</a></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.iswrappercall" href="#JuliaInterpreter.iswrappercall"><code>JuliaInterpreter.iswrappercall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Determine whether we are calling a function for which the current function is a wrapper (either because of optional arguments or becaue of keyword arguments).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/b51081ceb8c478d0310a6c861ffbc20800b9ccf3/src/interpret.jl#L490-L493">source</a></section><footer><hr/><a class="previous" href="../internals/"><span class="direction">Previous</span><span class="title">Internals</span></a></footer></article></body></html>
